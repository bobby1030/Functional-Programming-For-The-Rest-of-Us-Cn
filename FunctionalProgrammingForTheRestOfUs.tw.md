傻瓜函數式編程
============================================
2006年6月19日，星期一


###開篇
我們這些碼農做事都是很拖拉的。每天例行報到後，先來點咖啡，看看郵件還有RSS訂閱的文章。然後翻翻新聞還有那些技術網站上的更新，再過一遍編程論壇口水區裏那些無聊的論戰。最後從頭把這些再看一次以免錯過什麼精彩的內容。然後就可以吃午飯了。飯飽過後，回來盯着IDE發一會呆，再看看郵箱，再去搞杯咖啡。光陰似箭，可以回家了……    
（在被衆人鄙視之前）我唯一想說的是，在這些拖拉的日子裏總會時不時讀到一些[不明覺厲](http://www.baike.com/wiki/%E4%B8%8D%E6%98%8E%E8%A7%89%E5%8E%89)的文章。如果沒有打開不應該打開的網站，每隔幾天你都可以看到至少一篇這樣的東西。它們的共性：難懂，耗時，於是這些文章就慢慢的堆積成山了。很快你就會發現自己已經累積了一堆的收藏鏈接還有數不清的PDF文件，此時你只希望隱入一個杳無人煙的深山老林裏什麼也不做，用一年半載好好的消化這些私藏寶貝。當然，我是說最好每天還是能有人來給送吃的順帶幫忙打掃衛生倒垃圾，哇哈哈。   

我不知道你都收藏了些什麼，我的閱讀清單裏面相當大部分都是函數式編程相關的東東：基本上是最難啃的。這些文章充斥着無比枯燥的教科書語言，我想就連那些在華爾街浸淫10年以上的大牛都無法搞懂這些函數式編程（簡稱FP）文章到底在說什麼。你可以去花旗集團或者德意志銀行找個項目經理來問問<sup>1</sup>：你們爲什麼要選JMS而不用Erlang？答案基本上是：我認爲這個學術用的語言還無法勝任實際應用。可是，現有的一些系統不僅非常複雜還需要滿足十分嚴苛的需求，它們就都是用函數式編程的方法來實現的。這，就說不過去了。    
關於FP的文章確實比較難懂，但我不認爲一定要搞得那麼晦澀。有一些歷史原因造成了這種知識斷層，可是FP概念本身並不難理解。我希望這篇文章可以成爲一個“FP入門指南”，幫助你從[指令式編程](http://zh.wikipedia.org/zh/%E6%8C%87%E4%BB%A4%E5%BC%8F%E7%B7%A8%E7%A8%8B)走向[函數式編程](http://zh.wikipedia.org/zh/%E5%87%BD%E6%95%B8%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80)。先來點咖啡，然後繼續讀下去。很快你對FP的理解就會讓同事們刮目相看了。      

什麼是函數式編程（Functional Programming，FP）？它從何而來？可以吃嗎？倘若它真的像那些鼓吹FP的人說的那麼好，爲什麼實際應用中那麼少見？爲什麼只有那些在讀博士的傢伙想要用它？而最重要的是，它母親的怎麼就那麼難學？那些所謂的closure、continuation，currying，lazy evaluation還有no side effects都是什麼東東（譯者：本着保留專用術語的原則，此處及下文類似情形均不譯）？如果沒有那些大學教授的幫忙怎樣把它應用到實際工程裏去？爲什麼它和我們熟悉的萬能而神聖的指令式編程那麼的不一樣？      
我們很快就會解開這些謎團。剛纔我說過實際工程和學術界之間的知識斷層是有其歷史原因的，那麼就先讓我來解釋一下這個問題。答案，就在接下來的一次公園漫步中：

###公園漫步
時間機器啓動……我們來到公元前380年，也就是2000多年前的雅典城外。這是一個陽光明媚的久違的春天，[柏拉圖](http://zh.wikipedia.org/zh/%E6%9F%8F%E6%8B%89%E5%9B%BE)和一個帥氣的小男僕走在一片橄欖樹蔭下。他們正準備前往一個學院。天氣很好，吃得很飽，漸漸的，兩人的談話轉向了哲學。     

“你看那兩個學生，哪一個更高一些？”，柏拉圖小心的選擇用字，以便讓這個問題更好的引導眼前的這個小男孩。     
小男僕望向水池旁邊的兩個男生，“他們差不多一樣高。”。     
“‘差不多一樣高’是什麼意思？”柏拉圖問。    
“嗯……從這裏看來他們是一樣高的，但是如果走近一點我肯定能看出差別來。”     
柏拉圖笑了。他知道這個小孩已經朝他引導的方向走了。“這麼說來你的意思是世界上沒有什麼東西是完全相同的咯？”     
思考了一會，小男孩回答：“是的。萬物之間都至少有一丁點差別，哪怕我們無法分辨出來。”    
說到點子上了！“那你說，如果世界上沒有什麼東西是完全相等的，你怎麼理解‘完全相等’這個概念？”     
小男僕看起來很困惑。“這我就不知道了。”

這是人類第一次試圖瞭解數學的本質。柏拉圖認爲我們所在的世界中，萬事萬物都是完美模型的一個近似。他同時意識到雖然我們不能感受到完美的模型，但這絲毫不會阻止我們瞭解完美模型的概念。柏拉圖進而得出結論：完美的數學模型只存在於另外一個世界，而因爲某種原因我們卻可以通過聯繫着這兩個世界的一個紐帶來認識這些模型。一個簡單的例子就是完美的圓形。沒有人見過這樣的一個圓，但是我們知道怎樣的圓是完美的圓，而且可以用公式把它描述出來。      

如此說來，什麼是數學呢？爲什麼可以用數學法則來描述我們的這個宇宙？我們所處的這個世界中萬事萬物都可以用數學來描述嗎？<sup>2</sup>
數理哲學是一門很複雜的學科。它和其他多數哲學一樣，更着重於提出問題而不是給出答案。數學就像拼圖一樣，很多結論都是這樣推導出來的：先是確立一些互不衝突的基礎原理，以及一些操作這些原理的規則，然後就可以把這些原理以及規則拼湊起來形成新的更加複雜的規則或是定理了。數學家把這種方法稱爲“形式系統”或是“演算”。如果你想做的話，可以用形式系統描述俄羅斯方塊這個遊戲。而事實上，俄羅斯方塊這個遊戲的實現，只要它正確運行，就是一個形式系統。只不過它以一種不常見的形式表現出來罷了。     

如果[半人馬阿爾法](http://zh.wikipedia.org/wiki/%E5%8D%8A%E4%BA%BA%E9%A9%AC%E5%BA%A7%CE%B1)上有文明存在的話，那裏的生物可能無法解讀我們的俄羅斯方塊形式系統甚至是簡單的圓形的形式系統，因爲它們感知世界的唯一器官可能只有鼻子（譯者：偶的媽你咋知道？）也許它們是無法得知俄羅斯方塊的形式系統了，但是它們很有可能知道圓形。它們的圓形我們可能沒法解讀，因爲我們的鼻子沒有它們那麼靈敏（譯者：那狗可以麼？）可是只要越過形式系統的表示方式（比如通過使用“超級鼻子”之類的工具來感知這些用味道表示的形式系統，然後使用標準的解碼技術把它們翻譯成人類能理解的語言），那麼任何有足夠智力的文明都可以理解這些形式系統的本質。     
有意思的是，哪怕宇宙中完全不存在任何文明，類似俄羅斯方塊還有圓形這樣的形式系統依舊是成立的：只不過沒有智慧生物去發現它們而已。這個時候如果忽然一個文明誕生了，那麼這些具有智慧的生物就很有可能發現各種各樣的形式系統，並且用它們發現的系統去描述各種宇宙法則。不過它們可能不會發現俄羅斯方塊這樣的形式系統，因爲在它們的世界裏沒有俄羅斯方塊這種東西嘛。有很多像俄羅斯方塊這樣的形式系統是與客觀世界無關的，比如說自然數，很難說所有的自然數都與客觀世界有關，隨便舉一個超級大的數，這個數可能就和世界上任何事物無關，因爲這個世界可能不是無窮大的。

###歷史回眸<sup>3</sup>
再次啓動時間機……這次到達的是20世紀30年代，離今天近了很多。無論[新](http://zh.wikipedia.org/wiki/%E6%96%B0%E5%A4%A7%E9%99%B8)[舊](http://zh.wikipedia.org/wiki/%E8%88%8A%E5%A4%A7%E9%99%B8)大陸，經濟大蕭條都造成了巨大的破壞。社會各階層幾乎每一個家庭都深受其害。只有極其少數的幾個地方能讓人們免於遭受窮困之苦。幾乎沒有人能夠幸運的在這些避難所裏度過危機，注意，我說的是幾乎沒有，還真的有這麼些幸運兒，比如說當時普林斯頓大學的數學家們。    

新建成的哥特式辦公樓給普林斯頓大學帶來一種天堂般的安全感。來自世界各地的邏輯學者應邀來到普林斯頓，他們將組建一個新的學部。正當大部分美國人還在爲找不到一片麪包做晚餐而發愁的時候，在普林斯頓卻是這樣一番景象：高高的天花板和木雕包覆的牆，每天品茶論道，漫步叢林。
一個名叫[阿隆佐·邱奇](http://zh.wikipedia.org/zh/%E9%98%BF%E9%9A%86%E4%BD%90%C2%B7%E9%82%B1%E5%A5%87)(Alonzo Church)的年輕數學家就過着這樣優越的生活。阿隆佐本科畢業於普林斯頓後被留在研究院。他覺得這樣的生活完全沒有必要，於是他鮮少出現在那些數學茶會中也不喜歡到樹林裏散心。阿隆佐更喜歡獨處：自己一個人的時候他的工作效率更高。儘管如此他還是和普林斯頓學者保持着聯繫，這些人當中有[艾倫·圖靈](http://zh.wikipedia.org/zh/%E8%89%BE%E4%BC%A6%C2%B7%E5%9B%BE%E7%81%B5)、[約翰·馮·諾伊曼](http://zh.wikipedia.org/zh/%E7%BA%A6%E7%BF%B0%C2%B7%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC)、[庫爾特·哥德爾](http://zh.wikipedia.org/zh-hant/%E5%BA%93%E5%B0%94%E7%89%B9%C2%B7%E5%93%A5%E5%BE%B7%E5%B0%94)。     
這四個人都對形式系統感興趣。相對於現實世界，他們更關心如何解決抽象的數學問題。而他們的問題都有這麼一個共同點：都在嘗試解答關於計算的問題。諸如：如果有一臺擁有無窮計算能力的超級機器，可以用來解決什麼問題？它可以自動的解決這些問題嗎？是不是還是有些問題解決不了，如果有的話，是爲什麼？如果這樣的機器採用不同的設計，它們的計算能力相同嗎？     
在與這些人的合作下，阿隆佐設計了一個名爲[lambda演算](http://zh.wikipedia.org/wiki/%CE%9B%E6%BC%94%E7%AE%97)的形式系統。這個系統實質上是爲其中一個超級機器設計的編程語言。在這種語言裏面，函數的參數是函數，返回值也是函數。這種函數用希臘字母lambda（[λ](http://en.wikipedia.org/wiki/Lambda)），這種系統因此得名<sup>4</sup>。有了這種形式系統，阿隆佐終於可以分析前面的那些問題並且能夠給出答案了。    
除了阿隆佐·邱奇，艾倫·圖靈也在進行類似的研究。他設計了一種完全不同的系統（後來被稱爲[圖靈機](http://zh.wikipedia.org/zh/%E5%9B%BE%E7%81%B5%E6%9C%BA)），並用這種系統得出了和阿隆佐相似的答案。到了後來人們證明了圖靈機和lambda演算的能力是一樣的。    

如果二戰沒有發生，這個故事到這裏就應該結束了，我的這篇小文沒什麼好說的了，你們也可以去看看有什麼其他好看的文章。可是二戰還是爆發了，整個世界陷於火海之中。那時的美軍空前的大量使用炮兵。爲了提高轟炸的精度，軍方聘請了大批數學家夜以繼日的求解各種差分方程用於計算各種火炮發射數據表。後來他們發現單純手工計算這些方程太耗時了，爲瞭解決這個問題，各種各樣的計算設備應運而生。IBM製造的Mark一號就是用來計算這些發射數據表的第一臺機器。Mark一號重5噸，由75萬個零部件構成，每一秒可以完成3次運算。     
戰後，人們爲提高計算能力而做出的努力並沒有停止。1949年第一臺電子離散變量自動計算機誕生並取得了巨大的成功。它是[馮·諾伊曼設計架構](http://zh.wikipedia.org/zh/%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84)的第一個實例，也是一臺現實世界中實現的圖靈機。相比他的這些同事，那個時候阿隆佐的運氣就沒那麼好了。     
到了50年代末，一個叫John McCarthy的MIT教授（他也是普林斯頓的碩士）對阿隆佐的成果產生了興趣。1958年他發明瞭一種列表處理語言（Lisp），這種語言是一種阿隆佐lambda演算在現實世界的實現，而且它能在馮·諾伊曼計算機上運行！很多計算機科學家都認識到了Lisp強大的能力。1973年在MIT人工智能實驗室的一些程序員研發出一種機器，並把它叫做Lisp機。於是阿隆佐的lambda演算也有自己的硬件實現了！

### 函數式編程
函數式編程是阿隆佐思想的在現實世界中的實現。不過不是全部的lambda演算思想都可以運用到實際中，因lambda演算在設計的時候就不是爲了在各種現實世界中的限制下工作的。所以，就像面向對象的編程思想一樣，函數式編程只是一系列想法，而不是一套嚴苛的規定。有很多支持函數式編程的程序語言，它們之間的具體設計都不完全一樣。在這裏我將用Java寫的例子介紹那些被廣泛應用的函數式編程思想（沒錯，如果你是受虐狂你可以用Java寫出函數式程序）。在下面的章節中我會在Java語言的基礎上，做一些修改讓它變成實際可用的函數式編程語言。那麼現在就開始吧。     

Lambda演算在最初設計的時候就是爲了研究計算相關的問題。所以函數式編程主要解決的也是計算問題，而出乎意料的是，是用函數來解決的！（譯者：請理解原作者的苦心，我想他是希望加入一點調皮的風格以免讀者在中途睡着或是轉檯……）。函數就是函數式編程中的基礎元素，可以完成幾乎所有的操作，哪怕最簡單的計算，也是用函數完成的。我們通常理解的變量在函數式編程中也被函數代替了：在函數式編程中變量僅僅代表某個表達式（這樣我們就不用把所有的代碼都寫在同一行裏了）。所以我們這裏所說的‘變量’是不能被修改的。所有的變量只能被賦一次初值。在Java中就意味着每一個變量都將被聲明爲final（如果你用C++，就是const）。在FP中，沒有非final的變量。     

```java
final int i = 5;
final int j = i + 3;
```

既然FP中所有的變量都是final的，可以引出兩個規定：一是變量前面就沒有必要再加上final這個關鍵字了，二是變量就不能再叫做‘變量’了……於是現在開始對Java做兩個改動：所有Java中聲明的變量默認爲final，而且我們把所謂的‘變量’稱爲‘符號’。     
到現在可能會有人有疑問：這個新創造出來的語言可以用來寫什麼有用的複雜一些的程序嗎？畢竟，如果每個符號的值都是不能修改的，那麼我們就什麼東西都不能改變了！別緊張，這樣的說法不完全正確。阿隆佐在設計lambda演算的時候他並不想要保留狀態的值以便稍後修改這些值。他更關心的是基於數據之上的操作（也就是更容易理解的“計算”）。而且，lambda演算和圖靈機已經被證明了是具有同樣能力的系統，因此指令式編程能做到的函數式編程也同樣可以做到。那麼，怎樣才能做到呢？     
事實上函數式程序是可以保存狀態的，只不過它們用的不是變量，而是函數。狀態保存在函數的參數中，也就是說在棧上。如果你需要保存一個狀態一段時間並且時不時的修改它，那麼你可以編寫一個遞歸函數。舉個例子，試着寫一個函數，用來反轉一個Java的字符串。記住咯，這個程序裏的變量都是默認爲final的<sup>5</sup>。

```java
String reverse(String arg) {
    if(arg.length == 0) {
        return arg;
    }
    else {
        return reverse(arg.substring(1, arg.length)) + arg.substring(0, 1);
    }
}
```

這個方程運行起來會相對慢一些，因爲它重複調用自己<sup>6</sup>。同時它也會大量的消耗內存，因爲它會不斷的分配創建內存對象。無論如何，它是用函數式編程思想寫出來的。這時候可能有人要問了，爲什麼要用這種奇怪的方式編寫程序呢？嘿，我正準備告訴你。

###FP之優點
你大概已經在想：上面這種怪胎函數怎麼也不合理嘛。在我剛開始學習FP的時候我也這樣想的。不過後來我知道我是錯的。使用這種方式編程有很多好處。其中一些是主觀的。比如說有人認爲函數式程序更容易理解。這個我就不說了，哪怕街上隨便找個小孩都知道‘容易理解’是多麼主觀的事情。幸運的是，客觀方面的好處還有很多。

####單元測試
因爲FP中的每個符號都是final的，於是沒有什麼函數會有副作用。誰也不能在運行時修改任何東西，也沒有函數可以修改在它的作用域之外修改什麼值給其他函數繼續使用（在指令式編程中可以用類成員或是全局變量做到）。這意味着決定函數執行結果的唯一因素就是它的返回值，而影響其返回值的唯一因素就是它的參數。    
這正是單元測試工程師夢寐以求的啊。現在測試程序中的函數時只需要關注它的參數就可以了。完全不需要擔心函數調用的順序，也不用費心設置外部某些狀態值。唯一需要做的就是傳遞一些可以代表邊界條件的參數給這些函數。相對於指令式編程，如果FP程序中的每一個函數都能通過單元測試，那麼我們對這個軟件的質量必將信心百倍。反觀Java或者C++，僅僅檢查函數的返回值是不夠的：代碼可能修改外部狀態值，因此我們還需要驗證這些外部的狀態值的正確性。在FP語言中呢，就完全不需要。

####調試查錯
如果一段FP程序沒有按照預期設計那樣運行，調試的工作幾乎不費吹灰之力。這些錯誤是百分之一百可以重現的，因爲FP程序中的錯誤不依賴於之前運行過的不相關的代碼。而在一個指令式程序中，一個bug可能有時能重現而有些時候又不能。因爲這些函數的運行依賴於某些外部狀態， 而這些外部狀態又需要由某些與這個bug完全不相關的代碼通過某個特別的執行流程才能修改。在FP中這種情況完全不存在：如果一個函數的返回值出錯了，它一直都會出錯，無論你之前運行了什麼代碼。    
一旦問題可以重現，解決它就變得非常簡單，幾乎就是一段愉悅的旅程。中斷程序的運行，檢查一下棧，就可以看到每一個函數調用時使用的每一個參數，這一點和指令式代碼一樣。不同的是指令式程序中這些數據還不足夠，因爲函數的運行還可能依賴於成員變量，全局變量，還有其他類的狀態（而這些狀態又依賴於類似的變量）。FP中的函數只依賴於傳給它的參數，而這些參數就在眼前！還有，對指令式程序中函數返回值的檢查並不能保證這個函數是正確運行的。還要逐一檢查若干作用域以外的對象以確保這個函數沒有對這些牽連的對象做出什麼越軌的行爲（譯者：好吧，翻譯到這裏我自己已經有點激動了）。對於一個FP程序，你要做的僅僅是看一下函數的返回值。     
把棧上的數據過一遍就可以得知有哪些參數傳給了什麼函數，這些函數又返回了什麼值。當一個返回值看起來不對頭的那一刻，跳進這個函數看看裏面發生了什麼。一直重複跟進下去就可以找到bug的源頭！

####併發執行
不需要任何改動，所有FP程序都是可以併發執行的。由於根本不需要採用鎖機制，因此完全不需要擔心死鎖或是併發競爭的發生。在FP程序中沒有哪個線程可以修改任何數據，更不用說多線程之間了。這使得我們可以輕鬆的添加線程，至於那些禍害併發程序的老問題，想都不用想！     
既然是這樣，爲什麼沒有人在那些高度並行的那些應用程序中採用FP編程呢？事實上，這樣的例子並不少見。愛立信開發了一種FP語言，名叫Erlang，並應用在他們的電信交換機上，而這些交換機不僅容錯度高而且拓展性強。許多人看到了Erlang的這些優勢也紛紛開始使用這一語言。在這裏提到的電信交換控制系統遠遠要比華爾街上使用的系統具有更好的擴展性也更可靠。事實上，用Erlang搭建的系統並不具備可擴展性和可靠性，而Java可以提供這些特性。Erlang只是像岩石一樣結實不容易出錯而已。     
FP關於並行的優勢不僅於此。就算某個FP程序本身只是單線程的，編譯器也可以將其優化成可以在多CPU上運行的併發程序。以下面的程序爲例：

```java
String s1 = somewhatLongOperation1();
String s2 = somewhatLongOperation2();
String s3 = concatenate(s1, s2);
```

如果是函數式程序，編譯器就可以對代碼進行分析，然後可能分析出生成字符串s1和s2的兩個函數可能會比較耗時，進而安排它們並行運行。這在指令式編程中是無法做到的，因爲每一個函數都有可能修改其外部狀態，然後接下來的函數又可能依賴於這些狀態的值。在函數式編程中，自動分析代碼並找到適合並行執行的函數十分簡單，和分析C的內聯函數沒什麼兩樣。從這個角度來說用FP風格編寫的程序是“永不過時”的（雖然我一般不喜歡說大話空話，不過這次就算個例外吧）。硬件廠商已經沒辦法讓CPU運行得再快了。他們只能靠增加CPU核的數量然後用並行來提高運算的速度。這些廠商故意忽略一個事實：只有可以並行的軟件才能讓你花大價錢買來的這些硬件物有所值。指令式的軟件中只有很小一部分能做到跨核運行，而所有的函數式軟件都能實現這一目標，因爲FP的程序從一開始就是可以並行運行的。

####熱部署
在Windows早期，如果要更新系統那可是要重啓電腦的，而且還要重啓很多次。哪怕只是安裝一個新版本的播放器。到了XP的時代這種情況得到比較大的改善，儘管還是不理想（我工作的時候用的就是Windows，就在現在，我的系統托盤上就有個討厭的圖標，我不重啓機子就不消失）。這一方面Unix好一些，曾經。只需要暫停一些相關的部件而不是整個操作系統，就可以安裝更新了。雖然是要好一些了，對很多服務器應用來說這也還是不能接受的。電信系統要求的是100%的在線率，如果一個救急電話因爲系統升級而無法撥通，成千上萬的人就會因此喪命。同樣的，華爾街的那些公司怎麼也不能說要安裝軟件而在整個週末停止他們系統的服務。     
最理想的情況是更新相關的代碼而不用暫停系統的其他部件。對指令性程序來說是不可能的。想想看，試着在系統運行時卸載掉一個Java的類然後再載入這個類的新的實現，這樣做的話系統中所有該類的實例都會立刻不能運行，因爲該類的相關狀態已經丟失了。這種情況下可能需絞盡腦汁設計複雜的版本控制代碼，需要將所有這種類正在運行的實例[序列化](http://zh.wikipedia.org/wiki/%E5%BA%8F%E5%88%97%E5%8C%96)，逐一銷燬它們，然後創建新類的實例，將現有數據也序列化後裝載到這些新的實例中，最後希望負責裝載的程序可以正確的把這些數據移植到新實例中並正常的工作。這種事很麻煩，每次有新的改動都需要手工編寫裝載程序來完成更新，而且這些裝載程序還要很小心，以免破壞了現有對象之間的聯繫。理論上是沒問題，可是實際上完全行不通。    
FP的程序中所有狀態就是傳給函數的參數，而參數都是儲存在棧上的。這一特性讓軟件的熱部署變得十分簡單。只要比較一下正在運行的代碼以及新的代碼獲得一個diff，然後用這個diff更新現有的代碼，新代碼的熱部署就完成了。其它的事情有FP的語言工具自動完成！如果還有人認爲這隻存在於科幻小說中，他需要再想想：多年來Erlang工程師已經使用這種技術對它們的系統進行升級而完全不用暫停運行了。     

####機器輔助優化及證明
FP語言有一個特性很有意思，那就是它們是可以用數學方法來分析的。FP語言本身就是形式系統的實現，只要是能在紙上寫出來的數學運算就可以用這種語言表述出來。於是只要能夠用數學方法證明兩段代碼是一致的，編譯器就可以把某段代碼解析成在數學上等同的但效率又更高的另外一段代碼<sup>7</sup>。 關係數據庫已經用這種方法進行優化很多年了。沒有理由在常規的軟件行業就不能應用這種技術。
另外，還可以用這種方法來證明代碼的正確性，甚至可以設計出能夠自動分析代碼併爲單元測試自動生成邊緣測試用例的工具出來！對於那些對缺陷零容忍的系統來說，這一功能簡直就是無價之寶。例如心臟起搏器，例如飛行管控系統，這幾乎就是必須滿足的需求。哪怕你正在開發的程序不是爲了完成什麼重要核心任務，這些工具也可以幫助你寫出更健壯的程序，直接甩競爭對手n條大街。

###高階函數
我還記得在瞭解到FP以上的各種好處後想到：“這些優勢都很吸引人，可是，如果必須非要用這種所有變量都是final的蹩腳語言，估計還是不怎麼實用吧”。其實這樣的想法是不對的。對於Java這樣的指令式語言來說，如果所有的變量都是必須是final的，那麼確實很束手束腳。然而對函數式語言來說，情況就不一樣了。函數式語言提供了一種特別的抽象工具，這種工具將幫助使用者編寫FP代碼，讓他們甚至都沒想到要修改變量的值。高階函數就是這種工具之一。     
FP語言中的函數有別於Java或是C。可以說這種函數是一個[全集](http://zh.wikipedia.org/wiki/%E5%85%A8%E9%9B%86)：Java函數可以做到的它都能做，同時它還有更多的能力。首先，像在C裏寫程序那樣創建一個函數：

```c
int add(int i, int j) {
    return i + j;
}
```

看起來和C程序沒什麼區別，但是很快你就可以看出區別來。接下來我們擴展Java的編譯器以便支持這種代碼，也就是說，當我們寫下以上的程序編譯器會把它轉化成下面的Java程序（別忘了，所有的變量都是final的）：

```java
class add_function_t {
    int add(int i, int j) {
        return i + j;
    }
}

add_function_t add = new add_function_t();
```

在這裏，符號add並不是一個函數，它是只有一個函數作爲其成員的簡單的類。這樣做有很多好處，可以在程序中把add當成參數傳給其他的函數，也可以把add賦給另外一個符號，還可以在運行時創建add_function_t的實例然後在不再需要這些實例的時候由系統回收機制處理掉。這樣做使得函數成爲和integer或是string這樣的[第一類對象](http://zh.wikipedia.org/zh/%E7%AC%AC%E4%B8%80%E9%A1%9E%E7%89%A9%E4%BB%B6)。對其他函數進行操作（比如說把這些函數當成參數）的函數，就是所謂的高階函數。別讓這個看似高深的名字嚇倒你（譯者：好死不死起個這個名字，初一看還準備搬出已經塵封的高數教材……），它和Java中操作其他類（也就是把一個類實例傳給另外的類）的類沒有什麼區別。可以稱這樣的類爲“高階類”，但是沒人會在意，因爲Java圈裏就沒有什麼很強的學術社團。（譯者：這是高級黑嗎？）     
那麼什麼時候該用高階函數，又怎樣用呢？我很高興有人問這個問題。設想一下，你寫了一大堆程序而不考慮什麼類結構設計，然後發現有一部分代碼重複了幾次，於是你就會把這部分代碼獨立出來作爲一個函數以便多次調用（所幸學校裏至少會教這個）。如果你發現這個函數裏有一部分邏輯需要在不同的情況下實現不同的行爲，那麼你可以把這部分邏輯獨立出來作爲一個高階函數。搞暈了？下面來看看我工作中的一個真實的例子。

假設有一段Java的客戶端程序用來接收消息，用各種方式對消息做轉換，然後發給一個服務器。

```java
class MessageHandler {
    void handleMessage(Message msg) {
        // ...
        msg.setClientCode("ABCD_123");
        // ...
        
        sendMessage(msg);
    }
    
    // ...
}
```

再進一步假設，整個系統改變了，現在需要發給兩個服務器而不再是一個了。系統其他部分都不變，唯獨客戶端的代碼需要改變：額外的那個服務器需要用另外一種格式發送消息。應該如何處理這種情況呢？我們可以先檢查一下消息要發送到哪裏，然後選擇相應的格式把這個消息發出去：

```java
class MessageHandler {
    void handleMessage(Message msg) {
        // ...
        if(msg.getDestination().equals("server1") {
            msg.setClientCode("ABCD_123");
        } else {
            msg.setClientCode("123_ABC");
        }
        // ...
        
        sendMessage(msg);
    }
    
    // ...
}
```

可是這樣的實現是不具備擴展性的。如果將來需要增加更多的服務器，上面函數的大小將呈線性增長，使得維護這個函數最終變成一場噩夢。面向對象的編程方法告訴我們，可以把MessageHandler變成一個基類，然後將針對不同格式的消息編寫相應的子類。

```java
abstract class MessageHandler {
    void handleMessage(Message msg) {
        // ...
        msg.setClientCode(getClientCode());
        // ...
        
        sendMessage(msg);
    }
    
    abstract String getClientCode();
    
    // ...
}

class MessageHandlerOne extends MessageHandler {
    String getClientCode() {
        return "ABCD_123";
    }
}

class MessageHandlerTwo extends MessageHandler {
    String getClientCode() {
        return "123_ABCD";
    }
}
```

這樣一來就可以爲每一個接收消息的服務器生成一個相應的類對象，添加服務器就變得更加容易維護了。可是，這一個簡單的改動引出了很多的代碼。僅僅是爲了支持不同的客戶端行爲代碼，就要定義兩種新的類型！現在來試試用我們剛纔改造的語言來做同樣的事情，注意，這種語言支持高階函數：

```java
class MessageHandler {
    void handleMessage(Message msg, Function getClientCode) {
        // ...
        Message msg1 = msg.setClientCode(getClientCode());
        // ...
        
        sendMessage(msg1);
    }
    
    // ...
}

String getClientCodeOne() {
    return "ABCD_123";
}

String getClientCodeTwo() {
    return "123_ABCD";
}

MessageHandler handler = new MessageHandler();
handler.handleMessage(someMsg, getClientCodeOne);
```

在上面的程序裏，我們沒有創建任何新的類型或是多層類的結構。僅僅是把相應的函數作爲參數進行傳遞，就做到了和用面向對象編程一樣的事情，而且還有額外的好處：一是不再受限於多層類的結構。這樣做可以做運行時傳遞新的函數，可以在任何時候改變這些函數，而且這些改變不僅更加精準而且觸碰的代碼更少。這種情況下編譯器其實就是在替我們編寫面向對象的“粘合”代碼（譯者：又稱膠水代碼，粘接代碼）！除此之外我們還可以享用FP編程的其他所有優勢。函數式編程能提供的抽象服務還遠不止於此。高階函數只不過是個開始。

###Currying
我遇見的大多數碼農都讀過“[四人幫](http://baike.baidu.com/view/66964.htm#2)”的那本《設計模式》。任何稍有自尊心的碼農都會說這本書和語言無關，因此無論你用什麼編程語言，當中提到的那些模式大體上適用於所有軟件工程。聽起來很厲害，然而事實卻不是這樣。    
函數式語言的表達能力很強。用這種語言編程的時候基本不需要設計模式，因爲這種語言層次已經足夠高，使得使用者可以以概念編程，從而完全不需要設計模式了。以[適配器模式](http://zh.wikipedia.org/wiki/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F)爲例（有人知道這個模式和[外觀模式](http://zh.wikipedia.org/wiki/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F)有什麼區別嗎？怎麼覺得有人爲了出版合同的要求而硬生生湊頁數？）（譯者：您不愧是高級黑啊）。對於一個支持currying技術的語言來說，這個模式就是多餘的。     
在Java中最有名的適配器模式就是在其“默認”抽象單元中的應用：類。在函數式語言中這種模式其實就是函數。在這個模式中，一個接口被轉換成另外一個接口，讓不同的用戶代碼調用。接下來就有一個適配器模式的例子：

```java
int pow(int i, int j);
int square(int i)
{
    return pow(i, 2);
}
```

上面的代碼中square函數計算一個整數的平方，這個函數的接口被轉換成計算一個整數的任意整數次冪。在學術圈裏這種簡單的技術就被叫做currying（因爲邏輯學家[哈斯凱爾·加里](http://zh.wikipedia.org/wiki/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F)用其數學技巧將這種技術描述出來，於是就以他的名字來命名了）。在一個FP語言中函數（而不是類）被作爲參數進行傳遞，currying常常用於轉化一個函數的接口以便於其他代碼調用。函數的接口就是它的參數，於是currying通常用於減少函數參數的數量（見前例）。     
函數式語言生來就支持這一技術，於是沒有必要爲某個函數手工創建另外一個函數去包裝並轉換它的接口，這些函數式語言已經爲你做好了。我們繼續拓展Java來支持這一功能。    

```java
square = int pow(int i, 2);
```

上面的語句實現了一個平方計算函數，它只需要一個參數。它會繼而調用pow函數並且把第二個參數置爲2。編譯過後將生成以下Java代碼：

```java
class square_function_t {
    int square(int i) {
        return pow(i, 2);
    }
}
square_function_t square = new square_function_t();
```

從上面的例子可以看到，很簡單的，函數pow的封裝函數就創建出來了。在FP語言中currying就這麼簡單：一種可以快速且簡單的實現函數封裝的捷徑。我們可以更專注於自己的設計，編譯器則會爲你編寫正確的代碼！什麼時候使用currying呢？很簡單，當你想要用適配器模式（或是封裝函數）的時候，就是用currying的時候。

###[惰性求值](http://zh.wikipedia.org/zh/%E6%83%B0%E6%80%A7%E6%B1%82%E5%80%BC)
惰性求值（或是延遲求值）是一種有趣的技術，而當我們投入函數式編程的懷抱後這種技術就有了得以實現的可能。前面介紹併發執行的時候已經提到過如下代碼：

```java
String s1 = somewhatLongOperation1();
String s2 = somewhatLongOperation2();
String s3 = concatenate(s1, s2);
```

在指令式語言中以上代碼執行的順序是顯而易見的。由於每個函數都有可能改動或者依賴於其外部的狀態，因此必須順序執行。先是計算somewhatLongOperation1，然後到somewhatLongOperation2，最後執行concatenate。函數式語言就不一樣了。    
在前面討論過，somewhatLongOperation1和somewhatLongOperation2是可以併發執行的，因爲函數式語言保證了一點：沒有函數會影響或者依賴於全局狀態。可是萬一我們不想要這兩個函數併發執行呢？這種情況下是不是也還是要順序執行這些函數？答案是否定的。只有到了執行需要s1、s2作爲參數的函數的時候，才真正需要執行這兩個函數。於是在concatenate這個函數沒有執行之前，都沒有需要去執行這兩個函數：這些函數的執行可以一直推遲到concatenate()中需要用到s1和s2的時候。假如把concatenate換成另外一個函數，這個函數中有條件判斷語句而且實際上只會需要兩個參數中的其中一個，那麼就完全沒有必要執行計算另外一個參數的函數了！Haskell語言就是一個支持惰性求值的例子。Haskell不能保證任何語句會順序執行（甚至完全不會執行到），因爲Haskell的代碼只有在需要的時候纔會被執行到。       
除了這些優點，惰性求值也有缺點。這裏介紹了它的優點，我們將在下一章節介紹這些缺點以及如何克服它們。     

####代碼優化
惰性求值使得代碼具備了巨大的優化潛能。支持惰性求值的編譯器會像數學家看待代數表達式那樣看待函數式程序：抵消相同項從而避免執行無謂的代碼，安排代碼執行順序從而實現更高的執行效率甚至是減少錯誤。在此基礎上優化是不會破壞代碼正常運行的。嚴格使用形式系統的基本元素進行編程帶來的最大的好處，是可以用數學方法分析處理代碼，因爲這樣的程序是完全符合數學法則的。

####抽象化控制結構
惰性求值技術提供了更高階的抽象能力，這提供了實現程序設計獨特的方法。比如說下面的控制結構：

```java
unless(stock.isEuropean()) {
    sendToSEC(stock);
}
```

程序中只有在stock爲European的時候才執行sendToSEC。如何實現例子中的unless？如果沒有惰性求值就需要求助於某種形式的宏（譯者：用if不行麼？），不過在像Haskell這樣的語言中就不需要那麼麻煩了。直接實現一個unless函數就可以！

```haskell
void unless(boolean condition, List code) {
    if(!condition)
        code;
}
```

請注意，如果condition值爲真，那就不會計算code。在其他嚴格語言（見[嚴格求值](http://zh.wikipedia.org/wiki/%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5#.E4.B8.A5.E6.A0.BC.E6.B1.82.E5.80.BC_.28Strict_evaluation.29)）中這種行爲是做不到的，因爲在進入unless這個函數之前，作爲參數的code已經被計算過了。
####無窮數據結構
惰性求值技術允許定義無窮數據結構，這要在嚴格語言中實現將非常複雜。例如一個儲存Fibonacci數列數字的列表。很明顯這樣一個列表是無法在有限的時間內計算出這個無窮的數列並存儲在內存中的。在像Java這樣的嚴格語言中，可以定義一個Fibonacci函數，返回這個序列中的某個數。而在Haskell或是類似的語言中，可以把這個函數進一步抽象化並定義一個Fibonacci數列的無窮列表結構。由於語言本身支持惰性求值，這個列表中只有真正會被用到的數纔會被計算出來。這讓我們可以把很多問題抽象化，然後在更高的層面上解決它們（比如可以在一個列表處理函數中處理無窮多數據的列表）。
####不足之處
俗話說天下沒有免費的午餐™。惰性求值當然也有其缺點。其中最大的一個就是，嗯，惰性。現實世界中很多問題還是需要嚴格求值的。比如說下面的例子：   

```java
System.out.println("Please enter your name: ");
System.in.readLine();
```

在惰性語言中沒人能保證第一行會中第二行之前執行！這也就意味着我們不能處理IO，不能調用系統函數做任何有用的事情（這些函數需要按照順序執行，因爲它們依賴於外部狀態），也就是說不能和外界交互了！如果在代碼中引入支持順序執行的代碼原語，那麼我們就失去了用數學方式分析處理代碼的優勢（而這也意味着失去了函數式編程的所有優勢）。幸運的是我們還不算一無所有。數學家們研究了不同的方法用以保證代碼按一定的順序執行（in a functional setting?）。這一來我們就可以同時利用到函數式和指令式編程的優點了！這些方法有continuations，monads以及uniqueness typing。這篇文章僅僅介紹了continuations，以後再討論monads和uniqueness typing。有意思的是呢，coutinuations處理強制代碼以特定順序執行之外還有其他很多出處，這些我們在後面也會提及。

###Continuation
continuation對於編程，就像是達芬奇密碼對於人類歷史一樣：它揭開了人類有史以來最大的謎團。好吧，也許沒有那麼誇張，不過它們的影響至少和當年發現負數有平方根不相上下。

我們對函數的理解只有一半是正確的，因爲這樣的理解基於一個錯誤的假設：函數一定要把其返回值返回給調用者。按照這樣的理解，continuation就是更加廣義的函數。這裏的函數不一定要把返回值傳回給調用者，相反，它可以把返回值傳給程序中的任意代碼。continuation就是一種特別的參數，把這種參數傳到函數中，函數就能夠根據continuation將返回值傳遞到程序中的某段代碼中。說得很高深，實際上沒那麼複雜。直接來看看下面的例子好了：

```java
int i = add(5, 10);
int j = square(i);
```

add這個函數將返回15然後這個值會賦給i，這也是add被調用的地方。接下來i的值又會被用於調用square。請注意支持惰性求值的編譯器是不能打亂這段代碼執行順序的，因爲第二個函數的執行依賴於第一個函數成功執行並返回結果。這段代碼可以用Continuation Pass Style（CPS）技術重寫，這樣一來add的返回值就不是傳給其調用者，而是直接傳到square裏去了。     

```java
int j = add(5, 10, square);
```

在上例中，add多了一個參數：一個函數，add必須在完成自己的計算後，調用這個函數並把結果傳給它。這時square就是add的一個continuation。上面兩段程序中j的值都是225。    

這樣，我們學習到了強制惰性語言順序執行兩個表達式的第一個技巧。再來看看下面IO程序（是不是有點眼熟？）：

```java
System.out.println("Please enter your name: ");
System.in.readLine();
```

這兩行代碼彼此之間沒有依賴關係，因此編譯器可以隨意的重新安排它們的執行順序。可是只要用CPS重寫它，編譯器就必須順序執行了，因爲重寫後的代碼存在依賴關繫了。

```java
 System.out.println("Please enter your name: ", System.in.readLine);
``` 

這段新的代碼中println需要結合其計算結果調用readLine，然後再返回readLine的返回值。這使得兩個函數得以保證按順序執行而且readLine總被執行（這是由於整個運算需要它的返回值作爲最終結果）。Java的println是沒有返回值的，但是如果它可以返回一個能被readnLine接受的抽象值，問題就解決了！（譯者：別忘了，這裏作者一開始就在Java的基礎上修改搭建自己的語言）當然，如果一直把函數按照這種方法串下去，代碼很快就變得不可讀了，可是沒有人要求你一定要這樣做。可以通過在語言中添加[語法糖](http://zh.wikipedia.org/wiki/%E8%AF%AD%E6%B3%95%E7%B3%96)的方式來解決這個問題，這樣程序員只要按照順序寫代碼，編譯器負責自動把它們串起來就好了。於是就可以任意安排代碼的執行順序而不用擔心會失去FP帶來的好處了（包括可以用數學方法來分析我們的程序）！如果到這裏還有人感到困惑，可以這樣理解，函數只是有唯一成員的類的實例而已。試着重寫上面兩行程序，讓println和readLine編程這種類的實例，所有問題就都搞清楚了。       
到這裏本章基本可以結束了，而我們僅僅瞭解到continuation的一點皮毛，對它的用途也知之甚少。我們可以用CPS完成整個程序，程序裏所有的函數都有一個額外的continuation作爲參數接受其他函數的返回值。還可以把任何程序轉換爲CPS的，需要做的只是把當中的函數看作是特殊的continuation（總是將返回值傳給調用者的continuation）就可以了，簡單到完全可以由工具自動完成（史上很多編譯器就是這樣做的）。    

一旦將程序轉爲CPS的風格，有些事情就變得顯而易見了：每一條指令都會有一些continuation，都會將它的計算結果傳給某一個函數並調用它，在一個普通的程序中這個函數就是該指令被調用並且返回的地方。隨便找個之前提到過的代碼，比如說add(5,10)好了。如果add屬於一個用CPS風格寫出的程序，add的continuation很明顯就是當它執行結束後要調用的那個函數。可是在一個非CPS的程序中，add的continuation又是什麼呢？當然我們還是可以把這段程序轉成CPS的，可是有必要這樣做嗎？     
事實上沒有必要。注意觀察整個CPS轉換過程，如果有人嘗試要爲CPS程序寫編譯器並且認真思考過就會發現：CPS的程序是不需要棧的！在這裏完全沒有函數需要做傳統意義上的“返回”操作，函數執行完後僅需要接着調用另外一個函數就可以了。於是就不需要在每次調用函數的時候把參數壓棧再將它們從中取出，只要把這些參數存放在一片內存中然後使用跳轉指令就解決問題了。也完全不需要保留原來的參數：因爲這種程序裏的函數都不返回，所以它們不會被用第二次！     
簡單點說呢，用CPS風格寫出來的程序不需要棧，但是每次調用函數的時候都會要多加一個參數。非CPS風格的程序不需要額外的參數但又需要棧才能運行。棧裏面存的是什麼？僅僅是參數還有一個供函數運行結束後返回的程序指針而已。這個時候你是不是已經恍然大悟了？對啊，棧裏面的數據實際上就是continuation的信息！棧上的程序返回指針實質上就是CPS程序中需要調用的下一個函數！想要知道add(5, 10)的continuation是什麼？只要看它運行時棧的內容就可以了。      
接下來就簡單多了。continuation和棧上指示函數返回地址的指針其實是同一樣東西，只是continuation是顯式的傳遞該地址並且因此代碼就不侷限於只能返回到函數被調用的地方了。前面說過，continuation就是函數，而在我們特製的語言中函數就是類的實例，那麼可以得知棧上指向函數返回地址的指針和continuation的參數是一樣的，因爲我們所謂的函數（就像類的一個實例）其實就是指針。這也意味着在程序運行的任何時候，你都可以得到當前的continuation（就是棧上的信息）。     

好了，我們已經搞清楚當前的continuation是什麼了。接下來要弄明白它的存在有什麼意義。只要得到了當前的continuation並將它保存起來，就相當於保存了程序的當前狀態：在時間軸上把它凍結起來了。這有點像操作系統進入休眠狀態。continuation對象保存了足夠的信息隨時可以從指定的某個狀態繼續運行程序。在切換線程的時候操作系統也是這樣做的。唯一的區別在於它保留了所有的控制權利。當請求某個continuation對象時（在Scheme語言中是通過調用call-with-current-continuation函數實現的）得到的是一個存有當前continuation的對象，也就是棧對象（在CPS中也就是下一個要執行的函數）。可以把這個對象保存做一個變量中（或者是存在磁盤上）。當以該continuation對象“重啓”該程序時，程序的狀態就會立即“轉換”爲該對象中保存的狀態。這一點和切換回一個被暫停的線程或是從系統休眠中喚醒很相像，唯一不同的是continuatoin對象可以反覆的這樣使用。當系統喚醒後，休眠前保存的信息就會銷燬，否則你也可以反覆的從該點喚醒系統，就像乘時光機回到過去一樣。有了continuation你就可以做到這一點！       

那麼continuation在什麼情況下有用呢？有一些應用程序天生就沒有狀態，如果要在這樣的系統中模擬出狀態以簡化工作的時候，就可以用到continuation。最合適的應用場合之一就是網頁應用程序。微軟的ASP.NET爲了讓程序員更輕鬆的編寫應用程序，花了大量的精力去模擬各種狀態。假如C#支持continuation的話，那麼ASP.NET的複雜度將減半：因爲只要把某一時刻的continuation保存起來，下次用戶再次發起同樣請求的時候，重新載入這個continuation即可。對於網絡應用的程序員來說就再也沒有中斷了：輕輕鬆鬆程序就從下一行開始繼續運行了！對於一些實際問題來說，continuation是一種非常有用的抽象工具。如今大量的傳統胖客戶端（見[瘦客戶端](http://zh.wikipedia.org/wiki/%E7%98%A6%E5%AE%A2%E6%88%B7%E7%AB%AF)）正紛紛走進網絡，continuation在未來將扮演越來越重要的角色。

###模式匹配
模式匹配並不是什麼新功能。而事實上它和函數式編程也沒有什麼太大的關係。它之所以常常被認爲是FP的一個特性，是因爲在函數式語言已經支持模式匹配很長一段時間後的今天，指令式語言是還沒有這個功能。

還是直接用例子來看看什麼是模式匹配吧，這是一個用Java寫的Fibonacci函數：

```java
 int fib(int n) {
    if(n == 0) return 1;
    if(n == 1) return 1;
        
    return fib(n - 2) + fib(n - 1);
}
```

再看看用我們基於Java修改過的新語言寫出來的Fibonacci函數，這種新語言就支持模式匹配：

```java
 int fib(0) {
    return 1;
}
int fib(1) {
    return 1;
}
int fib(int n) {
    return fib(n - 2) + fib(n - 1);
}
```

區別在哪裏呢？在於後者的編譯器替我們實現了程序的分支。    
這有什麼了不起的？確實也沒什麼。只是有人注意到很多函數中有非常複雜的switch結構（對於函數式程序而言更是如此），於是想到如果能把這層結構也抽象化就更好了。然後就把這個複雜的函數拆分成若干新的函數，並在這些函數的某些參數中應用模式（這和[重載](http://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD)有點類似）。這樣依賴當這個函數被調用的時候，編譯器會在運行時將調用者傳入的參數與各個新函數的參數定義進行比較，找出合適的那個函數來執行。合適的函數往往是參數定義上最具體最接近傳入參數的那個函數。在這個例子中，當n爲1時，可以用函數int fib(int n)，不過真正調用的是int fib(1)因爲這個函數更具體更接近調用者的要求。     
模式匹配一般來說要比這裏舉的例子更加複雜。比如說，高級模式匹配系統可以支持下面的操作：

```java
int f(int n < 10) { ... }
int f(int n) { ... }
```

那麼什麼情況下模式匹配會有用呢？在需要處理一大堆程序分支的時候！每當需要實現複雜的嵌套if語句的時候，模式匹配可以幫助你用更少的代碼更好的完成任務。我所知道的一個這樣的函數是標準的WndProc函數，該函數是所有Win32應用程序必須具備的（儘管它經常會被抽象化）。模式匹配系統一般都可以像匹配簡單數值一樣匹配數據集合。舉個例子，對於一個接受數組作爲參數的函數，可以通過模式匹配數組中第一個數字爲1並且第三個數字大於3的輸入。
模式匹配的另外一個好處是每當需要添加或者修改程序分支時，再也不用面對那個龐大臃腫的函數了。只要添加（或者修改）相關的函數定義即可。有了模式匹配就不再需要四人幫的很多設計模式了。程序分支越多越複雜，模式匹配就越有用。而在習慣使用這一技術之後，你可能會懷疑沒有它你一天都過不下去了。

###Closure
目前爲止關於函數式編程各種功能的討論都只侷限在“純”函數式語言範圍內：這些語言都是lambda演算的實現並且都沒有那些和阿隆佐形式系統相衝突的特性。然而，很多函數式語言的特性哪怕是在lambda演算框架之外都是很有用的。確實，如果一個公理系統的實現可以用數學思維來看待程序，那麼這個實現還是很有用的，但這樣的實現卻不一定可以付諸實踐。很多現實中的語言都選擇吸收函數式編程的一些元素，卻又不完全受限於函數式教條的束縛。很多這樣的語言（比如Common Lisp）都不要求所有的變量必須爲final，可以修改他們的值。也不要求函數只能依賴於它們的參數，而是可以讀寫函數外部的狀態。同時這些語言又包含了FP的特性，如高階函數。與在lambda演算限制下將函數作爲參數傳遞不同，在指令式語言中要做到同樣的事情需要支持一個有趣的特性，人們常把它稱爲lexical closure。還是來看看例子。要注意的是，這個例子中變量不是final，而且函數也可以讀寫其外部的變量：

```java
 Function makePowerFn(int power) {
   int powerFn(int base) {
       return pow(base, power);
   }

   return powerFn;
}

Function square = makePowerFn(2);
square(3); // returns 9
```

makePowerFn函數返回另一個函數，這個新的函數需要一個整數參數然後返回它的平方值。執行square(3)的時候具體發生了什麼事呢？變量power並不在powerFn的域內，因爲makePowerFn早就運行結束返回了，所以它的棧也已經不存在了。那麼square又是怎麼正常工作的呢？這個時候需要語言通過某種方式支持繼續存儲power的值，以便square後面繼續使用。那麼如果再定義一個函數，cube，用來計算立方，又應該怎麼做呢？那麼運行中的程序就必須存儲兩份power的值，提供給makePowerFn生成的兩個函數分別使用。這種保存變量值的方法就叫做closure。closure不僅僅保存宿主函數的參數值，還可以用在下例的用法中：

```java
Function makeIncrementer() {
   int n = 0;

   int increment() {
       return ++n;
   }
}

Function inc1 = makeIncrementer();
Function inc2 = makeIncrementer();

inc1(); // returns 1;
inc1(); // returns 2;
inc1(); // returns 3;
inc2(); // returns 1;
inc2(); // returns 2;
inc2(); // returns 3;
```

運行中的程序負責存儲n的值，以便incrementer稍後可以訪問它。與此同時，程序還會保存多份n的拷貝，雖然這些值應該在makeIncrementer返回後就消失，但在這個情況下卻繼續保留下來給每一個incrementer對象使用。這樣的代碼編譯之後會是什麼樣子？closure幕後的真正工作機理又是什麼？這次運氣不錯，我們有一個後臺通行證，可以一窺究竟。    
一點小常識往往可以幫大忙。乍一看這些本地變量已經不再受限於基本的域限制並擁有無限的生命週期了。於是可以得出一個很明顯的結論：它們已經不是存在棧上，而是堆上了<sup>8</sup>。這麼說來closure的實現和前面討論過的函數差不多，只不過closure多了一個額外的引用指向其外部的變量而已：

```java
 class some_function_t {
   SymbolTable parentScope;
   
   // ...
}
```

當closure需要訪問不在它本地域的變量時，就可以通過這個引用到更外一層的父域中尋找該變量。謎底揭開了！closure將函數編程與面向對象的方法結合了起來。下一次爲了保存並傳遞某些狀態而創建類的時候，想想closure。它能在運行時從相應的域中獲得變量，從而可以把該變量當初“成員變量”來訪問，也因爲這樣，就不再需要去創建一個成員變量了。

###路在何方？
這篇文章僅僅涉及到函數式編程的一些皮毛。考慮到有時候星星之火可以燎原，所以如果它能給你一些幫助那就再好不過了。接下來我計劃就[範疇論](http://zh.wikipedia.org/wiki/%E8%8C%83%E7%95%B4%E8%AE%BA)、monads、函數式編程數據結構、函數式語言中的[類型系統](http://zh.wikipedia.org/wiki/%E9%A1%9E%E5%9E%8B%E7%B3%BB%E7%B5%B1)、並行函數式編程、數據庫的函數式編程以及更多的話題寫些類似的文章。如果我可以寫出（在我學習的同時）以上清單的一半，我的人生就完整了。於此同時，Google將是我們的良師益友。

###歡迎聯繫
如果您有任何問題，評價或者建議，請發郵件到coffeemug@gmail.com（譯者：如果翻譯方面的問題／建議請發到yang.huang@ymail.com:)）。期待您的回覆。

注：     
<sup>1</sup>當我在2005年求職時的的確確經常問別人這個問題。看着那些茫然的面孔實在是很好玩的事情。你們這些年薪30萬美金的傢伙，至少應該對自己可以利用的工具有個起碼的理解嘛。     
<sup>2</sup>這是個有爭議的問題。物理學家和數學家不得不承認目前還無法確定宇宙萬物是不是都遵從可以用數學方法描述的各種法則。     
<sup>3</sup>我一直一來都很討厭在歷史課上羅列一堆枯燥無味的時間、人名、事件。對我來說歷史就是關於那些改變世界的人們活生生的故事，是他們行爲背後的個人動機，是那些他們用以影響芸芸衆生的方法和工具。從這個角度來說，接下來的這堂歷史課是不完整的，很遺憾。只有那些非常相關的人和事會被提及。     
<sup>4</sup>在我學習函數式編程的時候，“lambda”這個術語搞得我很煩，因爲我不知道它到底是什麼意思。在這裏lambda就是一個函數，在數學符號中用這個希臘字母只是因爲它更容易寫。所以以後在談及函數式編程的時候只要你聽到lambda，把它在腦中翻譯爲“函數”就可以了。      
<sup>5</sup>有意思的是不論如何Java中的字符串總是不可修改的。討論這種背叛Java的設計背後的原因會很有意思，可惜這樣會讓我們跑題的。     
<sup>6</sup>大部分函數式語言的編譯器都會儘量將迭代函數轉換爲對等的循環語句。這種做法叫做[尾調用優化](http://zh.wikipedia.org/wiki/%E5%B0%BE%E8%B0%83%E7%94%A8)。      
<sup>7</sup>反之則不一定成立。儘管有時候可以證明兩段代碼是等價的，但不是在所有的情況下都可以得出這樣的結論。      
<sup>8</sup>實際上這樣做並不比棧上存儲要慢，因爲在引入[垃圾回收機制](http://zh.wikipedia.org/wiki/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8))後，內存分配操作的時間代價僅爲O(1)。     
